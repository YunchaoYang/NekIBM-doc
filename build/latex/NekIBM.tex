%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{NekIBM Documentation}
\date{Jun 11, 2020}
\release{beta}
\author{Yunchao Yang}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{NekIBM’s documentation}
\label{\detokenize{index:a-parallel-immersed-boundary-implementation-based-on-nek5000-cmtenk}}\label{\detokenize{index:nekibm-s-documentation}}

\section{Quickstart}
\label{\detokenize{quickstart::doc}}\label{\detokenize{quickstart:qstart}}\label{\detokenize{quickstart:quickstart}}

\subsection{Directory structure}
\label{\detokenize{quickstart:directory-structure}}

\subsection{Case files}
\label{\detokenize{quickstart:case-files}}

\subsection{Scripts}
\label{\detokenize{quickstart:scripts}}
Let’s walk through some useful batch scripts:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{makenek \textless{}case\textgreater{}}} compiles your case

\item {} 
\sphinxcode{\sphinxupquote{nek/nekb \textless{}case\textgreater{}}} runs a serial job in foreground or background

\item {} 
\sphinxcode{\sphinxupquote{nekmpi/nekbmpi \textless{}case\textgreater{} \textless{}number of ranks\textgreater{}}} runs a parallel job

\item {} 
\sphinxcode{\sphinxupquote{neknek \textless{}case1\textgreater{} \textless{}cas2\textgreater{} \textless{}ranks 1\textgreater{} \textless{}ranks 2\textgreater{}}} runs Nek5000 with two overlapping component grids

\item {} 
\sphinxcode{\sphinxupquote{visnek \textless{}case\textgreater{}}} creates metadata file required by \sphinxhref{https://wci.llnl.gov/simulation/computer-codes/visit/}{VisIt} and \sphinxhref{https://www.paraview.org/}{ParaView}.

\item {} 
\sphinxcode{\sphinxupquote{mvn \textless{}old name\textgreater{} \textless{}new name\textgreater{}}} renames all case files

\item {} 
\sphinxcode{\sphinxupquote{cpn \textless{}old name\textgreater{} \textless{}new name\textgreater{}}} copies all case files

\end{itemize}


\subsection{Meshing}
\label{\detokenize{quickstart:meshing}}
Nek5000 is mainly a solver. However, simple box type meshes can be generated with the \sphinxcode{\sphinxupquote{genbox}} tool. For more complex meshes please consider using \sphinxcode{\sphinxupquote{PRENEK}} and the meshing tools \sphinxcode{\sphinxupquote{nekmerge}} and \sphinxcode{\sphinxupquote{n2to3}}. We provide mesh converters like \sphinxcode{\sphinxupquote{exo2nek}} and \sphinxcode{\sphinxupquote{msh2nek}} which are quite handy if you want to use your favorite mesh generator. Also check our
\sphinxhref{https://github.com/Nek5000/NekBazaar}{Bazaar} for 3rd party meshing tools.


\subsection{Visualization}
\label{\detokenize{quickstart:qstart-vis}}\label{\detokenize{quickstart:visualization}}
Nek5000 output (\sphinxcode{\sphinxupquote{.fld}} or \sphinxcode{\sphinxupquote{0.f\%05d}}) files can be read by \sphinxhref{https://wci.llnl.gov/simulation/computer-codes/visit/}{VisIt} or
\sphinxhref{https://www.paraview.org/}{ParaView}. This requires using \sphinxcode{\sphinxupquote{visnek}} to generate a metadata file.
There is also an build-in X-Window based postprocessor called \sphinxcode{\sphinxupquote{POSTNEK}} located in tools.


\section{Tutorials}
\label{\detokenize{tutorials:id1}}\label{\detokenize{tutorials:tutorials}}\label{\detokenize{tutorials::doc}}
The following tutorials are provided to familiarize beginners with the features and typical workflow of Nek5000.
For a user brand new to Nek5000, we strongly recommend beginning with the Periodic Hill tutorial.


\section{Theory}
\label{\detokenize{theory::doc}}\label{\detokenize{theory:theory}}

\subsection{Computational Approach}
\label{\detokenize{theory:computational-approach}}\label{\detokenize{theory:intro-comput-approach}}
The spatial discretization is based on the spectral element method (SEM) \phantomsection\label{\detokenize{theory:id1}}{\hyperref[\detokenize{bibliography:patera1984}]{\sphinxcrossref{{[}Patera1984{]}}}}, which is a
high-order weighted residual technique similar to the finite element method.   In the SEM, the
solution and data are represented in terms of \(N\) th-order tensor-product polynomials within each
of \(E\) deformable hexahedral (brick) elements. Typical discretizations involve
\(E\)=100\textendash{}10,000 elements of order \(N\)=8\textendash{}16 (corresponding to 512\textendash{}4096 points per
element).  Vectorization and cache efficiency derive from the local lexicographical ordering within
each macro-element and from the fact that the action of discrete operators, which nominally have
\(O(EN^6)\) nonzeros, can be evaluated in only \(O(EN^4)\) work and \(O(EN^3)\) storage
through the use of tensor-product-sum factorization \phantomsection\label{\detokenize{theory:id2}}{\hyperref[\detokenize{bibliography:orszag1980}]{\sphinxcrossref{{[}Orszag1980{]}}}}.   The SEM exhibits very little
numerical dispersion and dissipation, which can be important, for example, in stability
calculations, for long time integrations, and for high Reynolds number flows. We refer to
\phantomsection\label{\detokenize{theory:id3}}{\hyperref[\detokenize{bibliography:denville2002}]{\sphinxcrossref{{[}Denville2002{]}}}} for more details.

Nek5000 solves the unsteady incompressible two-dimensional, axisymmetric, or three-dimensional
Stokes or Navier-Stokes equations with forced or natural convection heat transfer in both
stationary (fixed) or time-dependent geometry. It also solves the compressible Navier-Stokes in the
Low Mach regime, the magnetohydrodynamic equation (MHD).  The solution variables are the fluid
velocity \(\mathbf u=(u_{x},u_{y},u_{z})\), the pressure \(p\), the temperature \(T\).
All of the above field variables are functions of space \({\bf x}=(x,y,z)\) and time \(t\)
in domains \(\Omega_f\) and/or \(\Omega_s\) defined in \sphinxcode{\sphinxupquote{fig-walls}}.
Additionally Nek5000 can handle conjugate heat transfer problems.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{figs/walls}.png}
\caption{Computational domain showing respective fluid and solid subdomains, \(\Omega_f\) and
\(\Omega_s\).  The shared boundaries are denoted \(\partial\Omega_f=\partial\Omega_s\)
and the solid boundary which is not shared by fluid is \(\overline{\partial\Omega_s}\),
while the fluid boundary not shared by solid \(\overline{\partial\Omega_f}\).}\label{\detokenize{theory:fig-walls}}\label{\detokenize{theory:id6}}\end{figure}


\subsection{Incompressible Navier-Stokes Equations}
\label{\detokenize{theory:intro-ns}}\label{\detokenize{theory:incompressible-navier-stokes-equations}}
The governing equations of flow motion in dimensional form are
\begin{equation}\label{equation:theory:ns_momentum}
\begin{split}\rho\left(\frac{\partial\mathbf u}{\partial t} +\mathbf u \cdot \nabla \mathbf u\right) = - \nabla p + \nabla \cdot \boldsymbol\tau + \rho {\bf f} \,\, , \text{in } \Omega_f , \quad \text{  (Momentum)  }\end{split}
\end{equation}
where \(\boldsymbol\tau=\mu[\nabla \mathbf u+\nabla \mathbf u^{T}]\) and \(\mathbf f\) is a user defined acceleration.
\begin{equation}\label{equation:theory:ns_cont}
\begin{split}\nabla \cdot \mathbf u =0 \,\, , \text{in } \Omega_f, \quad \text{  (Continuity)  }\end{split}
\end{equation}
If the fluid viscosity is constant in the entire domain the viscous stress tensor can be contracted
\(\nabla\cdot\boldsymbol\tau=\mu\Delta \mathbf u\), therefore one may solve the Navier\textendash{}Stokes equations
in either the stress formulation, or no stress
\begin{itemize}
\item {} 
Variable viscosity requires the full stress tensor \(\nabla \cdot \boldsymbol\tau=\nabla \cdot
\mu[\nabla \mathbf u+\nabla \mathbf u^{T}]\), and we shall refer to this as the stress formulation

\item {} 
Constant viscosity leads to a simpler stress tensor \(\nabla \cdot \boldsymbol\tau=\mu\Delta \mathbf u\),
which we refer to as the ‘no stress’ formulation

\end{itemize}


\subsection{Non-Dimensional Navier-Stokes}
\label{\detokenize{theory:intro-ns-nondim}}\label{\detokenize{theory:non-dimensional-navier-stokes}}
Let us introduce the following non-dimensional variables \(\mathbf x^*\ = \frac{\mathbf x}{L}\),
\(\mathbf u^*\ = \frac{u}{U}\), \(t^*\ = \frac{tU}{L}\), and \(\mathbf f^* =\frac{\mathbf f L}{U^2}\).  For the pressure scale we have
two options:
\begin{itemize}
\item {} 
Convective effects are dominant i.e. high velocity flows \(p^* = \frac{p}{\rho U^2}\)

\item {} 
Viscous effects are dominant i.e. creeping flows (Stokes flow) \(p^* = \frac{p L}{\mu U}\)

\end{itemize}

For highly convective flows we choose the first scaling of the pressure and obtain the
non-dimensional Navier-Stokes:
\begin{equation}\label{equation:theory:NS_nondim}
\begin{split}\frac{\partial \mathbf{u^*}}{\partial t^*} + \mathbf{u^*} \cdot \nabla \mathbf{u^*}\ = -\nabla p^* + \frac{1}{Re} \nabla\cdot \boldsymbol\tau^* + \mathbf f^*.\end{split}
\end{equation}
where \(\boldsymbol\tau^*=[\nabla \mathbf u^*+\nabla \mathbf u^{*T}]\) and \(\mathbf f^*\) is the dimensionless user defined forcing function, e.g. gravity.

The non-dimensional number here is the Reynolds number \(Re=\frac{\rho U L}{\mu}\).


\subsection{Energy Equation}
\label{\detokenize{theory:energy-equation}}\label{\detokenize{theory:intro-energy}}
In addition to the fluid flow, Nek5000 computes automatically the energy equation
\begin{equation}\label{equation:theory:energy}
\begin{split}\rho c_{p} \left( \frac{\partial T}{\partial t} + \mathbf u \cdot \nabla T \right) =
   \nabla \cdot (k \nabla T) + q_{vol}\,\, ,\text{in } \Omega_f\cup \Omega_s  \text{  (Energy)  }\end{split}
\end{equation}

\subsection{Non-Dimensional Energy / Passive Scalar Equation}
\label{\detokenize{theory:intro-energy-nondim}}\label{\detokenize{theory:non-dimensional-energy-passive-scalar-equation}}
A similar non-dimensionalization as for the flow equations using the non-dimensional variables
\(\mathbf x^*\ = \frac{\mathbf x}{L}\),  \(\mathbf u^*\ = \frac{u}{U}\), \(t^*\ =
\frac{t}{L/U}\), \(T=\frac{T^*-T_0}{\delta T}\) leads to
\begin{equation}\label{equation:theory:energy_nondim}
\begin{split}\frac{\partial T^*}{\partial t^*} + \mathbf u^* \cdot \nabla T^* =
  \frac{1}{Pe} \nabla \cdot \nabla T^* + q_{vol}\,\, ,\text{in } \Omega_f\cup \Omega_s  \text{  (Energy)  }\end{split}
\end{equation}
where \(Pe=LU/\alpha\), with \(\alpha=k/\rho c_p\).


\subsection{Passive Scalars}
\label{\detokenize{theory:intro-pass-scal}}\label{\detokenize{theory:passive-scalars}}
We can additionally solve a convection-diffusion equation for each passive scalar \(\phi_i\),
\(i = 1,2,\ldots\) in \(\Omega_f \cup \Omega_s\)
\begin{equation}\label{equation:theory:pass_scal}
\begin{split}(\rho c_{p})_i \left( \frac{\partial \phi_{i}}{\partial t} + \mathbf u \cdot \nabla \phi_{i} \right) =
\nabla \cdot (k_i \nabla \phi_{i}) + (q_{vol})_i.\end{split}
\end{equation}
The terminology and restrictions of the temperature equations are retained for the passive scalars,
so that it is the responsibility of the user to convert the notation of the passive scalar
parameters to their thermal analogues.  For example, in the context of mass transfer, the user
should recognize that the values specified for temperature and heat flux will represent
concentration and mass flux, respectively.  Any combination of these equation characteristics is
permissible with the following restrictions. First, the equation must be set to unsteady if it is
time-dependent or if there is any type of advection. For these cases, the steady-state (if it
exists) is found as stable evolution of the initial-value-problem. Secondly, the stress formulation
must be selected if the geometry is time-dependent. In addition, stress formulation must be
employed if there are traction boundary conditions applied on any fluid boundary, or if any mixed
velocity/traction boundaries, such as symmetry and outflow/n, are not aligned with either one of
the Cartesian \(x,y\) or \(z\) axes.  Other capabilities of Nek5000 are the linearized
Navier-Stokes for flow stability, magnetohydrodynamic flows etc.


\subsection{Unsteady Stokes}
\label{\detokenize{theory:intro-ns-stokes}}\label{\detokenize{theory:unsteady-stokes}}
In the case of flows dominated by viscous effects Nek5000 can solve the reduced Stokes equations
\begin{equation}\label{equation:theory:ns_momentum_stokes}
\begin{split}\rho\left(\frac{\partial \mathbf u}{\partial t} \right) = - \nabla p + \nabla \cdot \boldsymbol\tau + \rho {\bf f} \,\, , \text{in } \Omega_f \text{  (Momentum)  }\end{split}
\end{equation}
where \(\boldsymbol\tau=\mu[\nabla \mathbf u+\nabla \mathbf u^{T}]\) and
\begin{equation}\label{equation:theory:ns_cont_stokes}
\begin{split}\nabla \cdot \mathbf u =0 \,\, , \text{in } \Omega_f  \text{  (Continuity)  }\end{split}
\end{equation}
Also here we can distinguish between the stress and non-stress formulation according to whether the
viscosity is variable or not. The non-dimensional form of these equations can be obtained using the
viscous scaling of the pressure.


\subsection{Steady Stokes}
\label{\detokenize{theory:steady-stokes}}\label{\detokenize{theory:intro-ns-steady-stokes}}
If there is no time-dependence, then Nek5000 can further reduce to
\begin{equation}\label{equation:theory:ns_momentum_steady_stokes}
\begin{split}- \nabla p + \nabla \cdot \boldsymbol\tau + \rho {\bf f}=0 \,\, , \text{in } \Omega_f \text{  (Momentum)  }\end{split}
\end{equation}
where \(\boldsymbol\tau=\mu[\nabla \mathbf u+\nabla {\mathbf u}^{T}]\) and
\begin{equation}\label{equation:theory:ns_cont_steady_stokes}
\begin{split}\nabla \cdot \mathbf u =0 \,\, , \text{in } \Omega_f  \text{  (Continuity)  }\end{split}
\end{equation}

\subsection{Linearized Equations}
\label{\detokenize{theory:intro-linear-eq}}\label{\detokenize{theory:linearized-equations}}
In addition to the basic evolution equations described above, Nek5000 provides support for the
evolution of small perturbations about a base state by solving the \sphinxstyleemphasis{linearized equations}
\begin{equation}\label{equation:theory:pertu}
\begin{split}\rho\left(\frac{\partial \mathbf u_i'}{\partial t} + \mathbf u \cdot \nabla {\mathbf u_i}^{'} + \mathbf u_i' \cdot \nabla \mathbf u \right) &=
- \nabla p_i' + \mu \nabla^2 \mathbf u_i'\\
\nabla \cdot \mathbf u_i' &= 0 \nonumber\end{split}
\end{equation}
for multiple perturbation fields \(i=1,2,\dots\) subject to different initial
conditions and (typically) homogeneous boundary conditions.

These solutions can be evolved concurrently with the base fields \((\mathbf u,p,T)\).  There is
also support for computing perturbation solutions to the Boussinesq equations for natural
convection.  Calculations such as these can be used to estimate Lyapunov exponents of chaotic
flows, etc.


\subsection{Steady Conduction}
\label{\detokenize{theory:steady-conduction}}\label{\detokenize{theory:intro-steady-conduct}}
The energy equation \eqref{equation:theory:energy} in which the advection term \(\mathbf u \cdot \nabla T\) and the
transient term \(\partial T/\partial t\) are zero. In essence this represents a Poisson equation.


\subsection{Low-Mach Navier-Stokes}
\label{\detokenize{theory:intro-low-mach}}\label{\detokenize{theory:low-mach-navier-stokes}}
The compressible Navier-Stokes differ mathematically from the incompressible ones mainly in the
divergence constraint \(\nabla \cdot \mathbf u\neq 0\).
In this case the system of equations is not closed and an additional equation of state (EOS) is required to connect the state variables, e.g. \(\rho=f(p,T)\).
Nek5000 includes the ability to solve the low-Mach approximation of the compressible Navier-Stokes, \(\rho\approx f(T)\).
The low-Mach approximation decouples the pressure from the velocity leading to a system of equations which can be solved numerically in a similar fashion as the incompressible Navier-Stokes.

The low-Mach equations are
\begin{equation}\label{equation:theory:lowmach}
\begin{split}\rho\left(\frac{\partial \mathbf u}{\partial t}+ \mathbf u\cdot\nabla\mathbf u\right)&=-\nabla p+\nabla \cdot\boldsymbol\tau+\rho\mathbf f\ \\
\nabla \cdot \mathbf u &= -\frac{1}{\rho}\frac{\mathrm d \rho}{\mathrm d T}\left(\frac{\partial T}{\partial t}+ \mathbf u\cdot\nabla T\right) \\
\rho c_p\left(\frac{\partial T}{\partial t}+ \mathbf u\cdot\nabla T\right)&=-\nabla \cdot k \nabla T + q_{vol}\end{split}
\end{equation}
where \(\boldsymbol\tau=\mu[\nabla \mathbf u+\nabla \mathbf u^{T}-\frac{2}{3}\nabla \cdot
\mathbf u \mathbf I]\).

This allows for both variable density and variable viscosity.
The system is solved by substituting \(\rho\approx f(T)\) into the continuity equation and obtaining a so-called thermal divergence.


\subsection{Incompressible MHD Equations}
\label{\detokenize{theory:intro-mhd}}\label{\detokenize{theory:incompressible-mhd-equations}}
Magnetohydrodynamics is based on the idea that magnetic fields can induce currents in a moving
conductive fluid, which in turn creates forces on the fluid and changing the magnetic field itself.
The set of equations which describe MHD are a combination of the Navier-Stokes equations of fluid
dynamics and Maxwell’s equations of electromagnetism. These differential equations have to be
solved simultaneously, and Nek5000 has an implementation for the incompressible MHD.

Consider a fluid of velocity \(\mathbf u\) subject to a magnetic field \(\mathbf B\) then
the incompressible MHD equations are
\begin{equation}\label{equation:theory:mhd}
\begin{split}\rho\left(\frac{\partial\mathbf u}{\partial t} + \mathbf u \cdot \nabla \mathbf u\right) &= - \nabla p + \mu \Delta \mathbf u + \mathbf B\cdot \nabla \mathbf B \ ,\\
\nabla \cdot \mathbf u &= 0\\ \nonumber
\frac{\partial \mathbf B}{\partial t} + \mathbf u \cdot \nabla \mathbf B &= - \nabla q + \eta \Delta \mathbf B + \mathbf B\cdot \nabla \mathbf u \ ,\\
\nabla \cdot \mathbf B &= 0\end{split}
\end{equation}
where \(\rho\) is the density \(\mu\) the viscosity, \(\eta\) resistivity, and pressure \(p\).

The total magnetic field can be split into two parts: \(\mathbf{B} = \mathbf{B_0} +
\mathbf{b}\) (mean + fluctuations). The above equations become in terms of Elsässer variables
(\(\mathbf{z}^{\pm} =  \mathbf{u} \pm \mathbf{b}\))
\begin{equation*}
\begin{split}\frac{\partial {\mathbf{z}^{\pm}}}{\partial t}\mp\left(\mathbf {B}_0\cdot{\mathbf \nabla}\right){\mathbf z^{\pm}} + \left({\mathbf z^{\mp}}\cdot{\mathbf \nabla}\right){\mathbf z^{\pm}} = -{\mathbf \nabla}p
+ \nu_+ \nabla^2 \mathbf{z}^{\pm} + \nu_- \nabla^2 \mathbf{z}^{\mp}\end{split}
\end{equation*}
where \(\nu_\pm = \nu \pm \eta\).

The important non-dimensional parameters for MHD are \(Re = U L /\nu\) and the magnetic Re \(Re_M = U L /\eta\).


\subsection{Arbitrary Lagrangian-Eulerian (ALE)}
\label{\detokenize{theory:arbitrary-lagrangian-eulerian-ale}}
We consider unsteady incompressible flow in a domain with moving boundaries:
\begin{equation}\label{equation:theory:mhd1}
\begin{split}\frac{\partial\mathbf u}{\partial t} = -\nabla p +\frac{1}{Re}\nabla\cdot(\nabla + \nabla^T)\mathbf u  + NL,\\
\nabla \cdot \mathbf u = 0\end{split}
\end{equation}
Here, \(NL\) represents the quadratic nonlinearities from the convective term.

Our free-surface hydrodynamic formulation is based upon the arbitrary Lagrangian-Eulerian (ALE)
formulation described in \phantomsection\label{\detokenize{theory:id4}}{\hyperref[\detokenize{bibliography:ho1989}]{\sphinxcrossref{{[}Ho1989{]}}}}.  Here, the domain \(\Omega(t)\) is also an unknown.  As
with the velocity, the geometry \(\mathbf x\) is represented by high-order polynomials.  For
viscous free-surface flows, the rapid convergence of the high-order surface approximation to the
physically smooth solution minimizes surface-tension-induced stresses arising from non-physical
cusps at the element interfaces, where only \(C^0\) continuity is enforced.  The geometric
deformation is specified by a mesh velocity \(\mathbf w := \dot{\mathbf x}\) that is
essentially arbitrary, provided that \(\mathbf w\) satisfies the kinematic condition
\(\mathbf w \cdot \hat{\mathbf n}|^{}_{\Gamma} = \mathbf u \cdot \hat{\mathbf
n}|^{}_{\Gamma}\), where \(\hat{\mathbf n}\) is the unit normal at the free surface
\(\Gamma(x,y,t)\).  The ALE formulation provides a very accurate description of the free
surface and is appropriate in situations where wave-breaking does not occur.

To highlight the key aspects of the ALE formulation, we introduce the weighted residual formulation
of Eq. \eqref{equation:theory:mhd1}: \sphinxstyleemphasis{Find} \((\mathbf u,p) \in X^N \times Y^N\) \sphinxstyleemphasis{such that:}
\begin{equation}\label{equation:theory:wrt1}
\begin{split}\frac{\mathrm d}{\mathrm d t}(\mathbf v,\mathbf u) = (\nabla \cdot \mathbf v,p) - \frac{2}{Re}(\nabla \mathbf v,\mathbf S)
+(\mathbf v,N\!L) + c(\mathbf v,\mathbf w,\mathbf u),
\qquad
(\nabla \cdot \mathbf u,q) = 0,\end{split}
\end{equation}
for all test functions \((\mathbf v,q) \in X^N \times Y^N\).  Here \((X^N,Y^N)\) are the
compatible velocity-pressure approximation spaces introduced in \phantomsection\label{\detokenize{theory:id5}}{\hyperref[\detokenize{bibliography:maday1989}]{\sphinxcrossref{{[}Maday1989{]}}}}, \((.,.)\) denotes
the inner-product \((\mathbf f,\mathbf g) := \int_{\Omega(t)} \mathbf f \cdot \mathbf g \,dV\),
and \(\mathbf S\) is the stress tensor \(S_{ij}^{} := \frac{1}{2}( \frac{\partial
u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i} )\).  For simplicity, we have neglected the
surface tension term.  A new term in Eq.  \eqref{equation:theory:wrt1} is the trilinear form involving the mesh
velocity
\begin{equation}\label{equation:theory:trilin}
\begin{split}c(\mathbf v,\mathbf w,\mathbf u) :=
\int_{\Omega(t)}^{}
\sum_{i=1}^3
\sum_{j=1}^3 v_i^{} \frac{\partial w_j^{} u_i^{}}{\partial x_j^{}} \,dV,\end{split}
\end{equation}
which derives from the Reynolds transport theorem when the time derivative is moved outside the
bilinear form \((\mathbf v,\mathbf u_t^{})\).  The advantage of Eq. \eqref{equation:theory:wrt1} is that it
greatly simplifies the time differencing and avoids grid-to-grid interpolation as the domain
evolves in time.  With the time derivative outside of the integral, each bilinear or trilinear form
involves functions at a specific time, \(t^{n-q}\), integrated over \(\Omega(t^{n-q})\).
For example, with a second-order backward-difference/extrapolation scheme, the discrete form of
Eq. \eqref{equation:theory:wrt1} is
\begin{equation}\label{equation:theory:bdk}
\begin{split}\frac{1}{2 \Delta t}\left[
 3 (\mathbf v^n,\mathbf u^n)^n
-4 (\mathbf v^{n-1},\mathbf u^{n-1})^{n-1}
 + (\mathbf v^{n-2},\mathbf u^{n-2})^{n-2} \right]
= L^n (\mathbf u) +
2 \widetilde{N\!L}^{n-1}
- \widetilde{N\!L}^{n-2}.\end{split}
\end{equation}
Here, \(L^n(\mathbf u)\) accounts for all \sphinxstyleemphasis{linear} terms in Eq. \eqref{equation:theory:wrt1}, including the
pressure and divergence-free constraint, which are evaluated implicitly (i.e., at time level
\(t^n\), on \(\Omega(t^n)\)), and \(\widetilde{N\!L}^{n-q}\) accounts for all
\sphinxstyleemphasis{nonlinear} terms, including the mesh motion term \eqref{equation:theory:trilin}, at time-level \(t^{n-q}\).
The superscript on the inner-products \((.,.)^{n-q}\) indicates integration over
\(\Omega(t^{n-q})\).  The overall time advancement is as follows.  The mesh position
\(\mathbf x^n \in \Omega(t^n)\) is computed explicitly using \(\mathbf w^{n-1}\) and
\(\mathbf w^{n-2}\); the new mass, stiffness, and gradient operators involving integrals and
derivatives on \(\Omega(t^n)\) are computed;  the extrapolated right-hand-side terms are
evaluated; and the implicit linear system is solved for \(\mathbf u^n\).   Note that it is only
the \sphinxstyleemphasis{operators} that are updated, not the \sphinxstyleemphasis{matrices}.  Matrices are never formed in Nek5000
and because of this, the overhead for the moving domain formulation is very low.


\section{Problem Setup}
\label{\detokenize{examples:id1}}\label{\detokenize{examples:problem-setup}}\label{\detokenize{examples::doc}}
A complete problem setup in Nek5000 requires a set of case files which are used for defining the geometry and physics of a problem.
Details of how to setup a case in Nek5000 are outlined in the following sections:


\section{Appendices}
\label{\detokenize{appendix::doc}}\label{\detokenize{appendix:appendices}}

\subsection{Build Options}
\label{\detokenize{appendix:build-options}}
The shell script \sphinxcode{\sphinxupquote{makenek}} is designed to assist the compilation process of Nek5000. The script will create a \sphinxcode{\sphinxupquote{makefile}} based on the user settings section in \sphinxcode{\sphinxupquote{makenek}}. The GNU gmake utility is used to build Nek5000.
Available configurations options:


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{Compiler options}\label{\detokenize{appendix:tab-bdms}}\label{\detokenize{appendix:id1}}
\sphinxaftercaption
\begin{tabular}[t]{|\X{12}{51}|\X{7}{51}|\X{12}{51}|\X{20}{51}|}
\hline
\sphinxstyletheadfamily 
name
&\sphinxstyletheadfamily 
values
&\sphinxstyletheadfamily 
default
&\sphinxstyletheadfamily 
description
\\
\hline
PPLIST
&
string
&&
list of pre-processor symbols (CVODE, …)
\\
\hline
MPI
&
1, 0
&
1
&
use MPI (needed for a multiprocessor computation)
\\
\hline&&&\\
\hline
FC
&
string
&
optional
&
Fortran compiler (mpif77)
\\
\hline
CC
&
string
&
optional
&
C compiler (mpicc)
\\
\hline
FCLAGS
&
string
&
optional
&
optional Fortan compilation flags
\\
\hline
CCLAGS
&
string
&
optional
&
optional C compilation flags
\\
\hline
SOURCE\_ROOT
&
string
&
optional
&
path of Nek5000 source
\\
\hline
USR
&
string
&
optional
&
object list of additional files to compile make intructions (\sphinxcode{\sphinxupquote{makefile\_usr.inc}} required)
\\
\hline
USR\_LFLAGS
&
string
&
optional
&
optional linking flags
\\
\hline
PROFILING
&
1, 0
&
1
&
enable internal timers for performance statistics
\\
\hline
VISIT
&
1, 0
&
0
&
Toggles Visit in situ. See Visit\_in\_situ for details
\\
\hline
VISIT\_INSTALL
&
string
&
VISIT in situ
&
Path to VISIT install path. See Visit\_in\_situ for details.
\\
\hline
VISIT\_STOP
&
true, false
&
false
&
When running VISIT in situ, simulation stops after step 1 to connect VISIT.
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

The \sphinxcode{\sphinxupquote{PPLIST}} field can be used to activate several features at compilation time.
A list of possible options is below:


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{PPLIST options}\label{\detokenize{appendix:tab-pplist}}\label{\detokenize{appendix:id2}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Symbol
&\sphinxstyletheadfamily 
Description
\\
\hline
NOMPIIO
&
deactivate MPI-IO support
\\
\hline
BGQ
&
use Blue Gene Q optimized mxm
\\
\hline
XSMM
&
use libxsmm for mxm
\\
\hline
CVODE
&
compile with CVODE support for scalars
\\
\hline
VENDOR\_BLAS
&
use VENDOR BLAS/LAPACK
\\
\hline
EXTBAR
&
add underscore to exit call (for BGQ)
\\
\hline
NEKNEK
&
activate overlapping mesh solver (experimental)
\\
\hline
CMTNEK
&
activate discontinuous Galerkin compressible-flow solver (experimental)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

In addition to these preprocessor items, the user can add compilation and linking flags.
\sphinxcode{\sphinxupquote{FFLAGS}} allows the user to add Fortran compilation flags while \sphinxcode{\sphinxupquote{CCFAGS}} allows the user to
add C compilation flags.
These will be compiler dependent and the user is encouraged to consult the manual of the compiler if specific options are needed/desired.
A commonly used flag is \sphinxcode{\sphinxupquote{-mcmodel}} which allows for arrays of size larger than 2GB.
This option  tells the compiler to use a specific memory model to generate code and store data.
It can affect code size and performance.
If your program has global and static data with a total size smaller than 2GB, \sphinxcode{\sphinxupquote{-mcmodel=small}} is sufficient.
Global and static data larger than 2GB requires \sphinxcode{\sphinxupquote{-mcmodel=medium}} or \sphinxcode{\sphinxupquote{-mcmodel=large}}.


\subsection{Internal Input Parameters/Switches}
\label{\detokenize{appendix:internal-input-parameters-switches}}

\subsubsection{Parameters}
\label{\detokenize{appendix:parameters}}


\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{P001}  density for the case of constant properties
\item[] 
\item[] \sphinxstylestrong{P002}  dynamic viscosity
\item[] 
\item[] \sphinxstylestrong{P007}  heat capacity for the case of constant properties
\item[] 
\item[] \sphinxstylestrong{P008}  conductivity for the case of constant properties
\item[] 
\item[] \sphinxstylestrong{P010}  simulation end time
\item[] 
\item[] \sphinxstylestrong{P011}  number of time steps
\item[] 
\item[] \sphinxstylestrong{P012}  time step size
\item[] 
\item[] \sphinxstylestrong{P014}  time fequency to dump fld files
\item[] 
\item[] \sphinxstylestrong{P015}  step frequency to dump fld files
\item[] 
\item[] \sphinxstylestrong{P021}  pressure solver tolernace
\item[] 
\item[] \sphinxstylestrong{P022}  velocity solver tolerance
\item[] 
\item[] \sphinxstylestrong{P023}  number of passive scalars
\item[] 
\item[] \sphinxstylestrong{P024}  relative tolerance for Helmholtz solver
\item[] 
\item[] \sphinxstylestrong{P025}  absolute tolerance for Helmholtz solver
\item[] 
\item[] \sphinxstylestrong{P026}  target Courant number (determines the number of RK4 substeps for OIFS)
\item[] 
\item[] \sphinxstylestrong{P027}  temporal discretization order
\item[] 
\item[] \sphinxstylestrong{P028}  temporal discretization order for mesh solver
\item[] 
\item[] \sphinxstylestrong{P029}  magnetic viscosity
\item[] 
\item[] \sphinxstylestrong{P030}  material properties (0: constant, 1: uservp)
\item[] 
\item[] \sphinxstylestrong{P031}  number of perturbation modes in linearized N-S.
\item[] 
\item[] \sphinxstylestrong{P032}  number of boundary conditions in .re2 file
\item[] 
\item[] \sphinxstylestrong{P033}  first field index in .re2
\item[] 
\item[] \sphinxstylestrong{P040}  pressure coarse grid solver (0: XXT, 1: AMG)
\item[] 
\item[] \sphinxstylestrong{P041} 1 \(\rightarrow\) multiplicative SEMG
\item[] 
\item[] \sphinxstylestrong{P042} linear solver for the pressure equation (0: GMRES, 1: CG)
\item[] 
\item[] \sphinxstylestrong{P043} 0: additive multilevel scheme - 1: original two level scheme.
\item[] 
\item[] \sphinxstylestrong{P044} 0=E-based additive Schwarz for PnPn-2; 1=A-based.
\item[] 
\item[] \sphinxstylestrong{P045} Free-surface stability control (defaults to 1.0)
\item[] 
\item[] \sphinxstylestrong{P046} if \(>0\), do not set Initial Condition (no call to subroutine \sphinxcode{\sphinxupquote{SETICS}}).
\item[] 
\item[] \sphinxstylestrong{P047} Poisson ratio for mesh elasticity solve (default 0.4)
\item[] 
\item[] \sphinxstylestrong{P054} direction of fixed flowrate (1: x, 2: y, 3: z), negative means fixed bulk
\item[] 
\item[] \sphinxstylestrong{P055} volumetric flowrate or bulk velocity (see p054) for periodic case
\item[] 
\item[] \sphinxstylestrong{P059} deformed element switch
\item[] 
\item[] \sphinxstylestrong{P060} initialize velocity to 1e-10 (for steady Stokes problem).
\item[] 
\item[] \sphinxstylestrong{P062} byte swap for output
\item[] 
\item[] \sphinxstylestrong{P063} output precision (4: SP, 8: DP)
\item[] 
\item[] \sphinxstylestrong{P064} restart perturbation solution
\item[] 
\item[] \sphinxstylestrong{P065} number of I/O nodes (if \(< 0\) write in separate subdirectories).
\item[] 
\item[] \sphinxstylestrong{P066} output format (0: ASCII, 4: legacy binary, 6: binary)
\item[] 
\item[] \sphinxstylestrong{P067} read format
\item[] 
\item[] \sphinxstylestrong{P068} averaging frequency in \sphinxcode{\sphinxupquote{avg\_all}} (0: every timestep).
\item[] 
\item[] \sphinxstylestrong{P084} custom inital time step
\item[] 
\item[] \sphinxstylestrong{P086} use skew-symmetric instead of convective form.
\item[] 
\item[] \sphinxstylestrong{P093} number of previous solutions to use for residual projection.
\item[] 
\item[] \sphinxstylestrong{P094} number of steps starting residual projection for velocity and passive scalars
\item[] 
\item[] \sphinxstylestrong{P095} number of steps starting residual projection for pressure
\item[] 
\item[] \sphinxstylestrong{P099} dealiasing mode (\(<0\): disabled, 3: old dealiasing, 4: new dealiasing)
\item[] 
\item[] \sphinxstylestrong{P100} \DUrole{red}{RESERVED!} pressure preconditioner when using CG solver (0: Jacobi, \(>0\): two-level Schwarz) \DUrole{red}{or viseversa?}
\item[] 
\item[] \sphinxstylestrong{P101} number of additional modes to filter
\item[] 
\item[] \sphinxstylestrong{P103} filter weight for last mode
\item[] 
\item[] \sphinxstylestrong{P107} if \(\neq0\), add it to \sphinxcode{\sphinxupquote{h2}} in \sphinxcode{\sphinxupquote{sethlm}}
\item[] 
\item[] \sphinxstylestrong{P116 NELX} number of elements in \(x\) for FTP
\item[] 
\item[] \sphinxstylestrong{P117 NELY} number of elements in \(y\) for FTP
\item[] 
\item[] \sphinxstylestrong{P118 NELZ} number of elements in \(z\) for FTP
\item[] 
\end{DUlineblock}


\subsubsection{Logical switches}
\label{\detokenize{appendix:logical-switches}}\label{\detokenize{appendix:sec-switches}}
\sphinxstylestrong{IFFLOW} solve for fluid (velocity, pressure)

\sphinxstylestrong{IFHEAT} solve for heat (temperature and/or scalars)

\sphinxstylestrong{IFTRAN} solve transient equations (otherwise, solve the steady Stokes flow)

\sphinxstylestrong{IFADVC} specify the fields with convection

\sphinxstylestrong{IFTMSH} specify the field(s) defined on T mesh  (first field is the ALE mesh)

\sphinxstylestrong{IFAXIS} axisymmetric formulation

\sphinxstylestrong{IFSTRS} use stress formulation

\sphinxstylestrong{IFLOMACH} use low Mach number formulation

\sphinxstylestrong{IFMGRID} moving grid

\sphinxstylestrong{IFMVBD} moving boundary (for free surface flow)

\sphinxstylestrong{IFCHAR} use characteristics for convection operator

\sphinxstylestrong{IFSYNC} use upfront synchronization

\sphinxstylestrong{IFUSERVP} user-defined properties


\subsubsection{Other Input Variables}
\label{\detokenize{appendix:other-input-variables}}
\sphinxstylestrong{filterType} 0: explicit, 1: HPT-RT

\sphinxstylestrong{restol(:)} field solver tolerance


\subsection{Commonly used Variables}
\label{\detokenize{appendix:commonly-used-variables}}

\subsubsection{Solution Variables}
\label{\detokenize{appendix:solution-variables}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
Variable Name
&\sphinxstyletheadfamily 
Size
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Short Description
\\
\hline
\sphinxcode{\sphinxupquote{vx}}
&
(lx1,ly1,lz1,lelv)
&
real
&
x-velocity (u)
\\
\hline
\sphinxcode{\sphinxupquote{vy}}
&
(lx1,ly1,lz1,lelv)
&
real
&
y-velocity (v)
\\
\hline
\sphinxcode{\sphinxupquote{vz}}
&
(lx1,ly1,lz1,lelv)
&
real
&
z-velocity (w)
\\
\hline
\sphinxcode{\sphinxupquote{pr}}
&
(lx2,ly2,lz2,lelv)
&
real
&
pressure (pr)
\\
\hline
\sphinxcode{\sphinxupquote{t}}
&
(lx1,ly1,lz1,lelt,ldimt)
&
real
&
temperature (t) and passive scalars (ps)
\\
\hline
\sphinxcode{\sphinxupquote{vtrans}}
&
(lx1,ly1,lz1,lelt,ldimt+1)
&
real
&
convective coefficient
\\
\hline
\sphinxcode{\sphinxupquote{vdiff}}
&
(lx1,ly1,lz1,lelt,ldimt+1)
&
real
&
diffusion coefficient
\\
\hline
\sphinxcode{\sphinxupquote{vxlag}}
&
(lx1,ly1,lz1,lelv,2)
&
real
&
x-velocity at previous time steps
\\
\hline
\sphinxcode{\sphinxupquote{vylag}}
&
(lx1,ly1,lz1,lelv,2)
&
real
&
y-velocity at previous time steps
\\
\hline
\sphinxcode{\sphinxupquote{vzlag}}
&
(lx1,ly1,lz1,lelv,2)
&
real
&
z-velocity at previous time steps
\\
\hline
\sphinxcode{\sphinxupquote{prlag}}
&
(lx2,ly2,lz2,lelv,lorder2)
&
real
&
pressure at previous time steps
\\
\hline
\sphinxcode{\sphinxupquote{tlag}}
&
(lx1,ly1,lz1,lelv,lorder-1,ldimt+1)
&
real
&
t and ps at previous time steps
\\
\hline
\sphinxcode{\sphinxupquote{time}}
&
\textendash{}
&
real
&
physical time
\\
\hline
\sphinxcode{\sphinxupquote{dt}}
&
\textendash{}
&
real
&
time step size
\\
\hline
\sphinxcode{\sphinxupquote{dtlag}}
&
( 10 )
&
real
&
previous time step sizes
\\
\hline
\sphinxcode{\sphinxupquote{istep}}
&
\textendash{}
&
integer
&
time step number
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Geometry Variables}
\label{\detokenize{appendix:geometry-variables}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
Variable Name
&\sphinxstyletheadfamily 
Size
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Short Description
\\
\hline
\sphinxcode{\sphinxupquote{xm1}}
&
(lx1,ly1,lz1,lelt)
&
real
&
x-coordinates for velocity mesh
\\
\hline
\sphinxcode{\sphinxupquote{ym1}}
&
(lx1,ly1,lz1,lelt)
&
real
&
y-coordinates for velocity mesh
\\
\hline
\sphinxcode{\sphinxupquote{zm1}}
&
(lx1,ly1,lz1,lelt)
&
real
&
z-coordinates for velocity mesh
\\
\hline
\sphinxcode{\sphinxupquote{bm1}}
&
(lx1,ly1,lz1,lelt)
&
real
&
mass matrix for velocity mesh
\\
\hline
\sphinxcode{\sphinxupquote{binvm1}}
&
(lx1,ly1,lz1,lelv)
&
real
&
inverse mass matrix for velocity mesh
\\
\hline
\sphinxcode{\sphinxupquote{bintm1}}
&
(lx1,ly1,lz1,lelt)
&
real
&
inverse mass matrix for t mesh
\\
\hline
\sphinxcode{\sphinxupquote{volvm1}}
&
\textendash{}
&
real
&
total volume for velocity mesh
\\
\hline
\sphinxcode{\sphinxupquote{voltm1}}
&
\textendash{}
&
real
&
total volume for t mesh
\\
\hline
\sphinxcode{\sphinxupquote{xm2}}
&
(lx2,ly2,lz2,lelv)
&
real
&
x-coordinates for pressure mesh
\\
\hline
\sphinxcode{\sphinxupquote{ym2}}
&
(lx2,ly2,lz2,lelv)
&
real
&
y-coordinates for pressure mesh
\\
\hline
\sphinxcode{\sphinxupquote{zm2}}
&
(lx2,ly2,lz2,lelv)
&
real
&
z-coordinates for pressure mesh
\\
\hline
\sphinxcode{\sphinxupquote{unx}}
&
(lx1,ly1,6,lelt)
&
real
&
x-component of face unit normal
\\
\hline
\sphinxcode{\sphinxupquote{uny}}
&
(lx1,ly1,6,lelt)
&
real
&
y-component of face unit normal
\\
\hline
\sphinxcode{\sphinxupquote{unz}}
&
(lx1,ly1,6,lelt)
&
real
&
z-component of face unit normal
\\
\hline
\sphinxcode{\sphinxupquote{area}}
&
(lx1,ly1,6,lelt)
&
real
&
face area (surface integral weights)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Problem Setup Variables}
\label{\detokenize{appendix:problem-setup-variables}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
Variable Name
&\sphinxstyletheadfamily 
Size
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Short Description
\\
\hline
\sphinxcode{\sphinxupquote{nid}}
&
\textendash{}
&
integer
&
MPI rank id (lowest rank is always 0)
\\
\hline
\sphinxcode{\sphinxupquote{nio}}
&
\textendash{}
&
integer
&
I/O node id
\\
\hline
\sphinxcode{\sphinxupquote{nelv}}
&
\textendash{}
&
integer
&
number of elements in velocity mesh
\\
\hline
\sphinxcode{\sphinxupquote{nelt}}
&
\textendash{}
&
integer
&
number of elements in t mesh
\\
\hline
\sphinxcode{\sphinxupquote{ndim}}
&
\textendash{}
&
integer
&
dimensionality of problem (i.e. 2 or 3)
\\
\hline
\sphinxcode{\sphinxupquote{nsteps}}
&
\textendash{}
&
integer
&
number of time steps to run
\\
\hline
\sphinxcode{\sphinxupquote{iostep}}
&
\textendash{}
&
integer
&
time steps between data output
\\
\hline
\sphinxcode{\sphinxupquote{cbc}}
&
(6,lelt,ldimt+1)
&
character*3
&
boundary condition
\\
\hline
\sphinxcode{\sphinxupquote{lglel}}
&
(lelt)
&
integer
&
local to global element number map
\\
\hline
\sphinxcode{\sphinxupquote{gllel}}
&
(lelg)
&
integer
&
global to local element number map
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Averaging Variables}
\label{\detokenize{appendix:averaging-variables}}
Arrays associated with the \sphinxcode{\sphinxupquote{avg\_all}} subroutine


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
Variable Name
&\sphinxstyletheadfamily 
Size
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Short Description
\\
\hline
\sphinxcode{\sphinxupquote{uavg}}
&
(ax1,ay1,az1,lelt)
&
real
&
time averaged x-velocity
\\
\hline
\sphinxcode{\sphinxupquote{vavg}}
&
(ax1,ay1,az1,lelt)
&
real
&
time averaged y-velocity
\\
\hline
\sphinxcode{\sphinxupquote{wavg}}
&
(ax1,ay1,az1,lelt)
&
real
&
time averaged z-velocity
\\
\hline
\sphinxcode{\sphinxupquote{pavg}}
&
(ax2,ay2,az2,lelt)
&
real
&
time averaged pressure
\\
\hline
\sphinxcode{\sphinxupquote{tavg}}
&
(ax1,ay1,az1,lelt,ldimt)
&
real
&
time averaged temperature and passive scalars
\\
\hline
\sphinxcode{\sphinxupquote{urms}}
&
(ax1,ay1,az1,lelt)
&
real
&
time averaged u\textasciicircum{}2
\\
\hline
\sphinxcode{\sphinxupquote{vrms}}
&
(ax1,ay1,az1,lelt)
&
real
&
time averaged v\textasciicircum{}2
\\
\hline
\sphinxcode{\sphinxupquote{wrms}}
&
(ax1,ay1,az1,lelt)
&
real
&
time averaged w\textasciicircum{}2
\\
\hline
\sphinxcode{\sphinxupquote{prms}}
&
(ax1,ay1,az1,lelt)
&
real
&
time averaged pr\textasciicircum{}2
\\
\hline
\sphinxcode{\sphinxupquote{trms}}
&
(ax1,ay1,az1,lelt,ldimt)
&
real
&
time averaged t\textasciicircum{}2 and ps\textasciicircum{}2
\\
\hline
\sphinxcode{\sphinxupquote{uvms}}
&
(ax1,ay1,az1,lelt)
&
real
&
time averaged uv
\\
\hline
\sphinxcode{\sphinxupquote{vwms}}
&
(ax1,ay1,az1,lelt)
&
real
&
time averaged vw
\\
\hline
\sphinxcode{\sphinxupquote{wums}}
&
(ax1,ay1,az1,lelt)
&
real
&
time averaged wu
\\
\hline
\sphinxcode{\sphinxupquote{iastep}}
&
\textendash{}
&
integer
&
time steps between averaged data output
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Commonly used Subroutines}
\label{\detokenize{appendix:commonly-used-subroutines}}\label{\detokenize{appendix:append-subroutines}}\begin{description}
\item[{\sphinxcode{\sphinxupquote{subroutine rescale\_x(x,x0,x1)}}}] \leavevmode
Rescales the array \sphinxcode{\sphinxupquote{x}} to be in the range \sphinxcode{\sphinxupquote{(x0,x1)}}. This is usually called from \sphinxcode{\sphinxupquote{usrdat2}} in the \sphinxcode{\sphinxupquote{.usr}} file

\item[{\sphinxcode{\sphinxupquote{subroutine normvc(h1,semi,l2,linf,x1,x2,x3)}}}] \leavevmode
Computes the error norms of a vector field variable \sphinxcode{\sphinxupquote{(x1,x2,x3)}} defined on mesh 1, the velocity mesh. The error norms are normalized with respect to the volume, with the exception on the infinity norm, \sphinxcode{\sphinxupquote{linf}}.

\item[{\sphinxcode{\sphinxupquote{subroutine comp\_vort3(vort,work1,work2,u,v,w)}}}] \leavevmode
Computes the vorticity (\sphinxcode{\sphinxupquote{vort}}) of the velocity field, \sphinxcode{\sphinxupquote{(u,v,w)}}

\item[{\sphinxcode{\sphinxupquote{subroutine lambda2(l2)}}}] \leavevmode
Generates the Lambda-2 vortex criterion proposed by Jeong and Hussain (1995)

\item[{\sphinxcode{\sphinxupquote{subroutine planar\_average\_z(ua,u,w1,w2)}}}] \leavevmode
Computes the r-s planar average of the quantity \sphinxcode{\sphinxupquote{u}}.

\item[{\sphinxcode{\sphinxupquote{subroutine torque\_calc(scale,x0,ifdout,iftout)}}}] \leavevmode
Computes torque about the point \sphinxcode{\sphinxupquote{x0}}. Here scale is a user supplied multiplier so that the results may be scaled to any convenient non-dimensionalization. Both the drag and the torque can be printed to the screen by switching the appropriate \sphinxcode{\sphinxupquote{ifdout(drag)}} or \sphinxcode{\sphinxupquote{iftout(torque)}} logical.

\item[{\sphinxcode{\sphinxupquote{subroutine set\_obj}}}] \leavevmode
Defines objects for surface integrals by changing the value of \sphinxcode{\sphinxupquote{hcode}} for future calculations. Typically called once within \sphinxcode{\sphinxupquote{userchk}} (for \sphinxcode{\sphinxupquote{istep = 0}}) and used for calculating torque. (see above)

\end{description}

\sphinxcode{\sphinxupquote{subroutine avg1(avg,f, alpha,beta,n,name,ifverbose)}}

\sphinxcode{\sphinxupquote{subroutine avg2(avg,f, alpha,beta,n,name,ifverbose)}}
\begin{description}
\item[{\sphinxcode{\sphinxupquote{subroutine avg3(avg,f,g, alpha,beta,n,name,ifverbose)}}}] \leavevmode
These three subroutines calculate the (weighted) average of \sphinxcode{\sphinxupquote{f}}. Depending on the value of the logical, \sphinxcode{\sphinxupquote{ifverbose}}, the results will be printed to standard output along with name. In \sphinxcode{\sphinxupquote{avg2}}, the \sphinxcode{\sphinxupquote{f}} component is squared. In \sphinxcode{\sphinxupquote{avg3}}, vector \sphinxcode{\sphinxupquote{g}} also contributes to the average calculation.

\item[{\sphinxcode{\sphinxupquote{subroutine outpost(x,vy,vz,pr,tz,' ')}}}] \leavevmode
Dumps the current data of \sphinxcode{\sphinxupquote{x}}, \sphinxcode{\sphinxupquote{vy}}, \sphinxcode{\sphinxupquote{vz}}, \sphinxcode{\sphinxupquote{pr}}, \sphinxcode{\sphinxupquote{tz}} to an \sphinxcode{\sphinxupquote{.fld}} or \sphinxcode{\sphinxupquote{.f0????}} file for post processing.

\item[{\sphinxcode{\sphinxupquote{subroutine platform\_timer(ivrb)}}}] \leavevmode
Runs the battery of timing tests for matrix-matrix products,contention-free processor-to-processor ping-pong tests, and \sphinxcode{\sphinxupquote{mpi\_all\_reduce}} times. Allows one to check the performance of the communication routines used on specific platforms.

\item[{\sphinxcode{\sphinxupquote{subroutine quickmv}}}] \leavevmode
Moves the mesh to allow user affine motion.

\item[{\sphinxcode{\sphinxupquote{subroutine runtimeavg(ay,y,j,istep1,ipostep,s5)}}}] \leavevmode
Computes, stores, and (for \sphinxcode{\sphinxupquote{ipostep!0}}) prints runtime averages of \sphinxcode{\sphinxupquote{j}}-quantity \sphinxcode{\sphinxupquote{y}} (along w/ \sphinxcode{\sphinxupquote{y}} itself unless \sphinxcode{\sphinxupquote{ipostep\textless{}0}}) with \sphinxcode{\sphinxupquote{j}} + ‘\sphinxcode{\sphinxupquote{rtavg\_}}’ + (unique) \sphinxcode{\sphinxupquote{s5}} every \sphinxcode{\sphinxupquote{ipostep}} for \sphinxcode{\sphinxupquote{istep\textgreater{}=istep1}}. \sphinxcode{\sphinxupquote{s5}} is a string to append to \sphinxcode{\sphinxupquote{rtavg\_}} for storage file naming.

\item[{\sphinxcode{\sphinxupquote{subroutine lagrng(uo,y,yvec,uvec,work,n,m)}}}] \leavevmode
Compute Lagrangian interpolant for \sphinxcode{\sphinxupquote{uo}}

\item[{\sphinxcode{\sphinxupquote{subroutine opcopy(a1,a2,a3,b1,b2,b3)}}}] \leavevmode
Copies \sphinxcode{\sphinxupquote{b1}} to \sphinxcode{\sphinxupquote{a1}}, \sphinxcode{\sphinxupquote{b2}} to \sphinxcode{\sphinxupquote{a2}}, and \sphinxcode{\sphinxupquote{b3}} to \sphinxcode{\sphinxupquote{a3}}, when \sphinxcode{\sphinxupquote{ndim = 3}},

\item[{\sphinxcode{\sphinxupquote{subroutine cadd(a,const,n)}}}] \leavevmode
Adds \sphinxcode{\sphinxupquote{const}} to vector \sphinxcode{\sphinxupquote{a}} of size \sphinxcode{\sphinxupquote{n}}.

\item[{\sphinxcode{\sphinxupquote{subroutine col2(a,b,n)}}}] \leavevmode
For \sphinxcode{\sphinxupquote{n}} entries, calculates \sphinxcode{\sphinxupquote{a=a*b}}.

\item[{\sphinxcode{\sphinxupquote{subroutine col3(a,b,c,n)}}}] \leavevmode
For \sphinxcode{\sphinxupquote{n}} entries, calculates \sphinxcode{\sphinxupquote{a=b*c}}.

\end{description}

\sphinxcode{\sphinxupquote{function glmax(a,n)}}

\sphinxcode{\sphinxupquote{function glamax(a,n)}}
\begin{description}
\item[{\sphinxcode{\sphinxupquote{function iglmax(a,n)}}}] \leavevmode
Calculates the (absolute) max of a vector that is size \sphinxcode{\sphinxupquote{n}}. Prefix \sphinxcode{\sphinxupquote{i}} implies integer type.

\item[{\sphinxcode{\sphinxupquote{function i8glmax(a,n)}}}] \leavevmode
Calculates the max of an integer*8 vector that is size \sphinxcode{\sphinxupquote{n}}.

\end{description}

\sphinxcode{\sphinxupquote{function glmin(a,n)}}

\sphinxcode{\sphinxupquote{function glamin(a,n)}}
\begin{description}
\item[{\sphinxcode{\sphinxupquote{function iglmin(a,n)}}}] \leavevmode
Calculates the (absolute) min of a vector that is size \sphinxcode{\sphinxupquote{n}}. Prefix \sphinxcode{\sphinxupquote{i}} implies integer type.

\end{description}

\sphinxcode{\sphinxupquote{function glsc2(a,b,n)}}

\sphinxcode{\sphinxupquote{function glsc3(a,b,mult,n)}}

\sphinxcode{\sphinxupquote{function glsc23(a,b,c,n)}}

\sphinxcode{\sphinxupquote{function glsum(a,n)}}
\begin{quote}

Computes the global sum of the real arrays \sphinxcode{\sphinxupquote{a}}, with number of local entries \sphinxcode{\sphinxupquote{n}}
\end{quote}

\sphinxcode{\sphinxupquote{function iglsum(a,n)}}
\begin{quote}

Computes the global sum of the integer arrays \sphinxcode{\sphinxupquote{a}}, with number of local entries \sphinxcode{\sphinxupquote{n}}
\end{quote}

\sphinxcode{\sphinxupquote{function i8glsum(a,n)}}
\begin{quote}

Computes the global sum of the integer*8 arrays \sphinxcode{\sphinxupquote{a}}, with number of local entries \sphinxcode{\sphinxupquote{n}}
\end{quote}
\begin{description}
\item[{\sphinxcode{\sphinxupquote{subroutine surface\_int(dphi,dS,phi,ielem,iside)}}}] \leavevmode
Computes the surface integral of scalar array \sphinxcode{\sphinxupquote{phi}} over face \sphinxcode{\sphinxupquote{iside}} of element \sphinxcode{\sphinxupquote{ielem}}.
The resulting integral is storted in \sphinxcode{\sphinxupquote{dphi}} and the area in \sphinxcode{\sphinxupquote{dS}}.

\end{description}


\subsection{Generating a Mesh with Genbox}
\label{\detokenize{appendix:mesh-gen}}\label{\detokenize{appendix:generating-a-mesh-with-genbox}}

\subsubsection{Uniformly Distributed Mesh}
\label{\detokenize{appendix:uniformly-distributed-mesh}}
Suppose you wish to simulate flow through an axisymmetric pipe,
of radius \(R=0.5\) and length \(L=4\).  You estimate that you will
need 3 elements in radial \((y)\) direction, and 5 in the \(x\) direction,
as depicted in \sphinxcode{\sphinxupquote{fig:mesh\_axi1}}.
This would be specified by the following input file (called \sphinxcode{\sphinxupquote{pipe.box}})
to \sphinxcode{\sphinxupquote{genbox}}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
axisymmetric.rea
2                      spatial dimension
1                      number of fields
\PYGZsh{}
\PYGZsh{}    comments:   This is the box immediately behind the
\PYGZsh{}                refined cylinder in Ugo\PYGZsq{}s cyl+b.l. run.
\PYGZsh{}
\PYGZsh{}
\PYGZsh{}========================================================
\PYGZsh{}
Box 1                         Pipe
\PYGZhy{}5 \PYGZhy{}3                         Nelx  Nely
0.0   4.0   1.0               x0  x1   ratio
0.0   0.5   1.0               y0  y1   ratio
v  ,O  ,A  ,W  ,   ,          BC\PYGZsq{}s:  (cbx0, cbx1, cby0, cby1, cbz0, cbz1)
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{figs/mesh_axi1}.png}
\caption{Axisymmetric pipe mesh.}\label{\detokenize{appendix:fig-mesh-axi1}}\label{\detokenize{appendix:id3}}\end{figure}
\begin{itemize}
\item {} 
The first line of this file supplies the name of an existing 2D \sphinxcode{\sphinxupquote{.rea}} file that has the appropriate run parameters (viscosity, timestep size, etc.). These parameters can be modified later, but it is important that \sphinxcode{\sphinxupquote{axisymmetric.rea}} be a 2D file, and not a 3D file.

\item {} 
The second line indicates the number of fields for this simulation, in this case, just 1, corresponding to the velocity field (i.e., no heat transfer).

\item {} 
The next set of lines just shows how one can place comments into a \sphinxcode{\sphinxupquote{genbox}} input file.

\item {} 
The line that starts with “Box” indicates that a new box is starting, and that the following lines describe a typical box input.  Other possible key characters (the first character of Box, “B”) are “C” and “M”, more on those later.

\item {} 
The first line after “Box” specifies the number of elements in the
\(x\) and \(y\) directions.   The fact that these values are negative indicates
that you want \sphinxcode{\sphinxupquote{genbox}} to automatically generate the element distribution
along each axis, rather than providing it by hand.  (More on this below.)

\item {} 
The next line specifies the distribution of the 5 elements in the \(x\) direction.
The mesh starts at \(x=0\) and ends at \(x=4.0\).  The \sphinxcode{\sphinxupquote{ratio}} indicates the
relative size of each element, progressing from left to right.

\item {} 
The next line specifies the distribution of the 3 elements in the \(y\) direction,
starting at \(y=0\) and going to \(y=0.5\).  Again,
\sphinxcode{\sphinxupquote{ratio}} =1.0 indicates that the elements will be of uniform height.

\item {} 
The last line specifies boundary conditions on each of the 4 sides of the
box:
\begin{itemize}
\item {} 
Lower-case \sphinxstyleemphasis{v} indicates that the left \((x)\) boundary is to be a velocity
boundary condition, with a user-specified distribution determined by
routine \sphinxcode{\sphinxupquote{userbc}} in the \sphinxcode{\sphinxupquote{.usr}} file.  (Upper-case \(V\) would indicate that
the velocity is constant, with values specified in the .rea file.)

\item {} 
\sphinxstyleemphasis{O} indicates that the right \((x)\) boundary is an outflow boundary \textendash{} the
flow leaves the domain at the left and the default exit pressure is \(p=0\).

\item {} 
\sphinxstyleemphasis{A} indicates that the lower \((y)\) boundary is the axis—this condition
is mandatory for the axisymmetric case, given the fact that the lower domain
boundary is at \(y=0\), which corresponds to \(r=0\).

\item {} 
\sphinxstyleemphasis{W} indicates that the upper \((y)\) boundary is a wall.  This would be
equivalent to a \sphinxstyleemphasis{v} or \sphinxstyleemphasis{V} boundary condition, with \({\bf u}=0\).

\end{itemize}

\end{itemize}


\subsubsection{Graded Mesh}
\label{\detokenize{appendix:graded-mesh}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{figs/mesh_axi2}.png}
\caption{Axisymmetric pipe mesh, graded}\label{\detokenize{appendix:fig-mesh-axi2}}\label{\detokenize{appendix:id4}}\end{figure}

Suppose you wish to have the mesh be graded,
that you have increased resolution near the wall.
In this case you change \sphinxcode{\sphinxupquote{ratio}} in the \(y\)-specification
of the element distribution.  For example, changing the 3 lines
in the above \sphinxcode{\sphinxupquote{genbox}} input file from

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}5 \PYGZhy{}3                         Nelx  Nely
0.0   4.0   1.0               x0  x1   ratio
0.0   0.5   1.0               y0  y1   ratio
\end{sphinxVerbatim}

to

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}5 \PYGZhy{}4                         Nelx  Nely
0.0   4.0   1.0               x0  x1   ratio
0.0   0.5   0.7               y0  y1   ratio
\end{sphinxVerbatim}

yields the mesh shown in \sphinxcode{\sphinxupquote{fig:mesh\_axi2}}.


\subsubsection{User-Specified Distribution}
\label{\detokenize{appendix:user-specified-distribution}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{figs/mesh_axi3}.png}
\caption{Axisymmetric pipe mesh, user specified.}\label{\detokenize{appendix:fig-mesh-axi3}}\label{\detokenize{appendix:id5}}\end{figure}

You can also specify your own, precise, distribution of element
locations.   For example, another graded mesh similar to the
one of the preceding example could be built by changing the
\sphinxcode{\sphinxupquote{genbox}} input file to contain:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}5  4                                               Nelx  Nely
0.0   4.0   1.0                                     x0  x1   ratio
0.000    0.250    0.375    0.450    0.500           y0  y1 ... y4
\end{sphinxVerbatim}

Here, the positive number of elements for the \(y\) direction indicates
that \sphinxcode{\sphinxupquote{genbox}} is expecting \sphinxcode{\sphinxupquote{Nely+1}} values of \(y\) positions on the
\(y\)-element distribution line.   This is the \sphinxcode{\sphinxupquote{genbox}} default, which
explains why it corresponds to \sphinxcode{\sphinxupquote{Nely}} \(>\) 0.  The corresponding mesh
is shown in \sphinxcode{\sphinxupquote{fig:mesh\_axi3}}.


\subsection{Mesh Modification}
\label{\detokenize{appendix:mesh-modification}}
For complex shapes, it is often convenient to modify the mesh
direction in the simulation code, Nek5000.  This can be done
through the \sphinxcode{\sphinxupquote{usrdat2}} routine provided in the \sphinxcode{\sphinxupquote{.usr}} file.
The routine \sphinxcode{\sphinxupquote{usrdat2}} is called by Nek5000 immediately after
the geometry, as specified by the \sphinxcode{\sphinxupquote{.rea}} file, is established.
Thus, one can use the existing geometry to map to a new geometry
of interest.

For example, suppose you want the above pipe geometry to have
a sinusoidal wall.  Let \({\bf x} := (x,y)\) denote the old geometry,
and \({\bf x}' := (x',y')\) denote the new geometry.  For a domain
with \(y\in [0,0.5]\), the following function will map the straight
pipe geometry to a wavy wall with amplitude \(A\), wavelength \(\lambda\):
\begin{equation*}
\begin{split}y'(x,y) = y  + y A \sin( 2 \pi x / \lambda ).\end{split}
\end{equation*}
Note that, as \(y \longrightarrow 0\), the perturbation,
\(yA \sin( 2 \pi x / \lambda )\), goes to zero.  So, near the axis,
the mesh recovers its original form.

In Nek5000, you would specify this through \sphinxcode{\sphinxupquote{usrdat2}} as follows

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{subroutine }\PYG{n}{usrdat2}
\PYG{k}{include} \PYG{l+s+s1}{\PYGZsq{}SIZE\PYGZsq{}}
\PYG{k}{include} \PYG{l+s+s1}{\PYGZsq{}TOTAL\PYGZsq{}}

\PYG{k+kt}{real }\PYG{n}{lambda}

\PYG{n}{ntot} \PYG{o}{=} \PYG{n}{nx1}\PYG{o}{*}\PYG{n}{ny1}\PYG{o}{*}\PYG{n}{nz1}\PYG{o}{*}\PYG{n}{nelt}

\PYG{n}{lambda} \PYG{o}{=} \PYG{l+m+mf}{3.}
\PYG{n}{A}      \PYG{o}{=} \PYG{l+m+mf}{0.1}

\PYG{k}{do }\PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{ntot}
   \PYG{n}{argx}         \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{*}\PYG{n}{xm1}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{/}\PYG{n}{lambda}
   \PYG{n}{ym1}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{n}{ym1}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{n}{ym1}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{A}\PYG{o}{*}\PYG{n+nb}{sin}\PYG{p}{(}\PYG{n}{argx}\PYG{p}{)}
\PYG{k}{end }\PYG{k}{do}

\PYG{n}{param}\PYG{p}{(}\PYG{l+m+mi}{59}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{1.}  \PYG{c}{! Force nek5 to recognize element deformation.}

\PYG{k}{return}
\PYG{k}{end}
\end{sphinxVerbatim}

Note that, since Nek5000 is modifying the mesh, \sphinxcode{\sphinxupquote{postx}} will not
recognize the current mesh unless you tell it to, because \sphinxcode{\sphinxupquote{postx}}
looks to the \sphinxcode{\sphinxupquote{.rea}} file for the mesh geometry.  The only way for
Nek5000 to communicate the new mesh to \sphinxcode{\sphinxupquote{postx}} is via the \sphinxcode{\sphinxupquote{.fld}}
file, so you must request that the geometry be dumped to the
\sphinxcode{\sphinxupquote{.fld}} file.
The result of above changes is shown in \sphinxcode{\sphinxupquote{fig:wavypipe}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{figs/wavypipe}.png}
\caption{Axisymmetric pipe mesh.}\label{\detokenize{appendix:fig-wavypipe}}\label{\detokenize{appendix:id6}}\end{figure}


\subsubsection{Cylindrical/Cartesian-transition Annuli}
\label{\detokenize{appendix:sec-genbox}}\label{\detokenize{appendix:cylindrical-cartesian-transition-annuli}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{figs/cylbox_2d}.png}
\caption{Cylinder mesh}\label{\detokenize{appendix:fig-cylbox-2d}}\label{\detokenize{appendix:id7}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{figs/cylbox_2da}.png}
\caption{Cylinder mesh}\label{\detokenize{appendix:fig-cylbox-2da}}\label{\detokenize{appendix:id8}}\end{figure}

More sophisticated
transition treatments may be generated using the GLOBAL REFINE options in
\sphinxcode{\sphinxupquote{prenek}} or through an upgrade of \sphinxcode{\sphinxupquote{genb7}}, as demand warrants.
Example 2D and 3D input files are provided in the \sphinxcode{\sphinxupquote{nek5000/doc}} files
\sphinxcode{\sphinxupquote{box7.2d}} and \sphinxcode{\sphinxupquote{box7.3d}}.
\sphinxcode{\sphinxupquote{fig:cylbox\_2d}} shows a 2D example generated using
the \sphinxcode{\sphinxupquote{box7.2d}} input file, which reads:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
x2d.rea
2                      spatial dimension
1                      number of fields
\PYGZsh{}
\PYGZsh{}    comments
\PYGZsh{}
\PYGZsh{}
\PYGZsh{}========================================================
\PYGZsh{}
Y                   cYlinder
3 \PYGZhy{}24 1             nelr,nel\PYGZus{}theta,nelz
.5 .3               x0,y0 \PYGZhy{} center of cylinder
ccbb                descriptors: c\PYGZhy{}cyl, o\PYGZhy{}oct, b\PYGZhy{}box (1 character + space)
.5 .55 .7 .8        r0 r1 ... r\PYGZus{}nelr
0  1  1             theta0/2pi theta1/2pi  ratio
v  ,W  ,E  ,E  ,    bc\PYGZsq{}s (3 characters + comma)
\end{sphinxVerbatim}

An example of a mesh is shown in \sphinxcode{\sphinxupquote{fig:cylbox\_2d}}.   The mesh has been quad-refined
once with oct-refine option of \sphinxcode{\sphinxupquote{prenek}}. The 3D counterpart to this
mesh could joined to a hemisphere/Cartesian transition built with
the spherical mesh option in \sphinxcode{\sphinxupquote{prenek}}.


\subsection{Mesh Extrusion and Mirroring}
\label{\detokenize{appendix:mesh-extrusion-and-mirroring}}
In \sphinxcode{\sphinxupquote{nek5000/tools}}, there is a code \sphinxcode{\sphinxupquote{n2to3.f}} that can be compiled with your
local fortran compiler (preferably not g77).
By running this code, you can extend two dimensional domains to
three dimensional ones with a user-specified number of levels in the
\(z\)-direction.  Such a mesh can then be modified using the mesh modification
approach. Assuming you have a valid two-dimensional mesh, \sphinxcode{\sphinxupquote{n2to3}} is straightforward
to run.  Below is a typical session, upon typing \sphinxcode{\sphinxupquote{n2to3}} the user is prompted at the command line

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
 Input old (source) file name:
h2e
 Input new (output) file name:
h3e
 input number of levels: (1, 2, 3,... etc.?):
16
 input z min:
0
 input z max:
16
 input gain (0=custom,1=uniform,other=geometric spacing):
1
 This is for CEM: yes or no:
n
 Enter Z (5) boundary condition (P,v,O):
v
 Enter Z (6) boundary condition (v,O):
0
 this is cbz: v  O   \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}

      320 elements written to h3e.rea
FORTRAN STOP
\end{sphinxVerbatim}

In this context CEM stands for computational electromagnetics, a spin-off of the original Nek5000 code.

The domain in which the fluid flow/heat transfer
problem is solved consists of two distinct subdomains. The
first subdomain is that part of the region occupied by
fluid, denoted \(\Omega_f\), while the second subdomain is that part
of the region occupied by a solid, denoted \(\Omega_s\). These two
subdomains are depicted in \sphinxcode{\sphinxupquote{fig-walls}}. The entire domain is denoted as \(D=\Omega_f \cup \Omega_s\).
The fluid problem is solved in the domain \(\Omega_f\), while the
temperature in the energy equation is solved in the
entire domain; the passive scalars can be solved in either
the fluid or the entire domain.

We denote the entire boundary of \(\Omega_f\) as \(\partial \Omega_f\), that part
of the boundary of \(\Omega_f\) which is not shared by \(\Omega_s\) as
\(\overline{\partial \Omega_f}\), and
that part of the boundary of \(\Omega_f\) which is shared by \(\Omega_s\).
In addition, \(\partial \Omega_{s}, \overline{\partial \Omega_s}\) are analogously defined.
These distinct portions of the
domain boundary are illustrated in \sphinxcode{\sphinxupquote{fig-walls}}.
The restrictions on the domain for Nek5000 are itemized below.
\begin{itemize}
\item {} 
The domain \(\Omega=\Omega_f \cup \Omega_s\) must correspond either to a
planar (Cartesian) two-dimensional geometry, or to the
cross-section of an axisymmetric region specified by
revolution of the cross-section about a specified axis, or
by a (Cartesian) three-dimensional geometry.

\item {} 
For two-dimensional and axisymmetric geometries, the
boundaries of both subdomains, \(\partial \Omega_f\) and
\(\partial \Omega_s\), must be
representable as (or at least approximated by) the union of
straight line segments, splines, or circular arcs.

\item {} 
Nek5000 can interpret a two-dimensional image as either
a planar Cartesian geometry, or
the cross-section of an axisymmetric body. In the case of
the latter, it is assumed that the \(y\)-direction is the radial
direction, that is, the axis of revolution is at \(y=0\).
Although an axisymmetric geometry is, in fact,
three-dimensional, Nek5000 can assume that the field variables
are also axisymmetric ( that is, do not depend on azimuth,
but only \(y\), that is, radius, \(x\), and \(t\) ), thus reducing the
relevant equations to “two-dimensional” form.

\end{itemize}

Fully general three-dimensional meshes generated by other softwares
packages can be input to \sphinxcode{\sphinxupquote{prenek}} as imported meshes.


\section{Bibliography}
\label{\detokenize{bibliography:bibliography}}\label{\detokenize{bibliography::doc}}
\begin{sphinxadmonition}{note}{Recommended Citation}

Zwick, D. (2019). ppiclF: A Parallel Particle-In-Cell Library in Fortran. \sphinxstyleemphasis{Journal of Open Source Software.} 4(37), 1400. \sphinxurl{https://doi.org/10.21105/joss.01400}
\end{sphinxadmonition}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}

\begin{sphinxthebibliography}{Denville2002}
\bibitem[Denville2002]{\detokenize{Denville2002}}{\phantomsection\label{\detokenize{bibliography:denville2002}} 
Deville, M.O. and P.F. Fischer and E.H. Mund. \sphinxstyleemphasis{High-order methods for
incompressible fluid flow.} Cambridge University Press, 2002.
}
\bibitem[Ho1989]{\detokenize{Ho1989}}{\phantomsection\label{\detokenize{bibliography:ho1989}} 
Ho, L.W.  A Legendre spectral element method for simulation of incompressible unsteady
viscous free-surface flows. Ph.D. thesis, Massachusetts Institute of Technology, 1989.
}
\bibitem[Maday1989]{\detokenize{Maday1989}}{\phantomsection\label{\detokenize{bibliography:maday1989}} 
Maday, Y. and A.T. Patera. Spectral element methods for the Navier-Stokes equations.
In \sphinxstyleemphasis{State-of-the-Art Surveys in Computational Mechanics}, pages 71\textendash{}143. ASME, New York, 1989.
}
\bibitem[Orszag1980]{\detokenize{Orszag1980}}{\phantomsection\label{\detokenize{bibliography:orszag1980}} 
Orszag, S.A. “Spectral methods for problems in complex geometry.” \sphinxstyleemphasis{J. Comput.
Phys.} \sphinxstylestrong{37}:70\textendash{}92, 1980.
}
\bibitem[Patera1984]{\detokenize{Patera1984}}{\phantomsection\label{\detokenize{bibliography:patera1984}} 
Patera, A.T. “A spectral element method for fluid dynamics : laminar flow in
a channel expansion.” \sphinxstyleemphasis{J. Comput. Phys.} \sphinxstylestrong{54}:468\textendash{}488, 1984.
}
\bibitem[Mellen2000]{\detokenize{Mellen2000}}{\phantomsection\label{\detokenize{bibliography:mellen2000}} 
Mellen, C. P., Fröhlich, J., Rodi, W. “Large-eddy simulation of the flow over periodic hills.” \sphinxstyleemphasis{16th
IMACS World Congress}, Lausanne, Switzerland.
}
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}